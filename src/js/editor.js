// http://jsfiddle.net/zmWs4/
// http://fabricjs.com/js/kitchensink/controller.js
// https://jsfiddle.net/drzaus/fa9jbu17/

( function( global )
{
	'use strict';
	let pie = global.pie = global.pie || { };
	
	// Main class
	pie.Editor =
	class Editor 
	{
		constructor( options ) 
		{
			// Generate a unique key
			this.id = Math.random( ).toString( 36 ).replace( /[^a-z]+/g, '' ).substr( 0, 5 );

			// Read the parameters
			this.options = $.extend( true, pie.defaultOptions, options );

			// Additional variables
			this.$elements = { }; // See main.js - "selectors"
			this.layers = [ ];
			this.tabs = { };

			// Initializing additional libraries
			this.utils = {
				tabs:		new pie.utils.Tabs( this ),
				template:	new pie.utils.Template( this ),
				layers:		new pie.utils.Layers( this ),
				toolbar:	new pie.utils.Toolbar( this )
			};

			// Embed the editor
			this._insertEditor( );

			// Write the editor to the list
			pie.list[ this.id ] = this;
		}

		// Embed Editor
		_insertEditor( )
		{
			// 
			let $container = $( this.options.container || body ),
				selectors = this.options.selectors || { };
			
			// Working with the default template
			if( this.options.container !== undefined )
			{
				// Template render
				let template = this.utils.template.render( 'main.tpl', { } );

				// Display the template data
				$container = $( template ).appendTo( this.options.container );
			}

			// Set main container
			this.$elements[ 'container' ] = $container;

			// Get elements
			for( let element in this.options.selectors  )
			{
				this.$elements[ element ] = $container.find( this.options.selectors[ element ] );
			}
			
			// Create fabricJS
			this.canvas = new fabric.Canvas( this.$elements[ 'canvas' ][ 0 ] );
			
			// Loading the tabs content
			this.utils.tabs.load( );
			
			// Loading the contents of the toolbar
			this.utils.toolbar.load( );

			// Layer list loading
			this.loadLayers( );
			
			// Set event handlers
			this.setEvents( );
		}

		// Getting Settings
		_getConfig( config, callback )
		{
			pie.helpers.config.load( 'config/' + config, callback );
		}
		
		// Save to File
		_saveToFile( fileName, content )
		{
			var link = document.createElement( 'a' );
				link.href = content;
				link.download = fileName;
				link.click( );
		}
		
		// Setting Events
		setEvents( )
		{
			const context = this;
			
			// Events generated by fabricJS
			// Positioning in the center https://stackoverflow.com/questions/43024617/snap-shape-to-center-with-fabricjs
			// 
			this.canvas.on( 
			{ 
				// Adding an object
				'object:added': function( ) {	context.loadLayers( ); },
				// Deleting an object
				'object:removed': function( ) { context.loadLayers( ); } 
			} );
					
			// Browser Events
			// https://stackoverflow.com/questions/24733030/fabric-js-moving-image-with-keyboard
			document.onkeydown = function( event ) 
			{
				//
				const movementDelta = 5,
					activeObject = context.canvas.getActiveObject( );
				
				//
				if( activeObject === undefined )
				{
					return;
				}
				
				//
				switch( event.keyCode ) 
				{
					// Up arrow
					case 38:
						activeObject.top -= movementDelta;
						break;
					// Down arrow	
					case 40:
						activeObject.top += movementDelta;
						break;
					// Left arrow	
					case 37:
						activeObject.left -= movementDelta;
						break;
					// Right arrow
					case 39:
						activeObject.left += movementDelta;
						break;
					// Delete
					case 46:
						context.utils.layers.remove( null, activeObject );
						break;
				}
				
				//
				if( [ 37, 38, 39, 40 ].indexOf( event.keyCode ) >= 0 )
				{
					event.preventDefault( );	
					context.canvas.renderAll( );
				}
			};
		}
		
		// List of objects on the canvas
		// http://jsfiddle.net/rodrigopandini/BGgDg/5/
		loadLayers( )
		{
			return this.utils.layers.load( );
		}
		
		// Image saving
		save( format )
		{	
			if( !fabric.Canvas.supports( 'toDataURL' ) ) 
			{
				alert( 'This browser doesn\'t provide means to serialize canvas to an image' );
			}
			else 
			{
				let format = format || 'png';
								
				// Remove the selection and update the canvas
				this.canvas.discardActiveObject( )
							.renderAll( );
				
				// Save in SVG
				if( format === 'svg' )
				{
					let SVGString = this.canvas.toSVG( );
					
					this._saveToFile( this.id + '.' + format, 'data:text/plain;charset=utf-8;base64,' + btoa( unescape( encodeURIComponent( SVGString ) ) ) );
				}
				else
				{
					let imageString = this.canvas.toDataURL( { format: format, quality: 0.8 } );
					
					this._saveToFile( this.id + '.' + format, imageString );
				}
			}
		}
		
		// Export to JSON
		exportToJSON( )
		{
			var jsonData = JSON.stringify( this.canvas.toDatalessJSON( ) ); 

			// Save the file
			this._saveToFile( this.id + '.json', 'data:text/plain;charset=utf-8;base64,' + btoa( jsonData ) );
		}

		// Import form JSON
		importFromJSON( json )
		{
			let context = this;
			
			fabric.loadSVGFromString( json , function( objects, options ) 
			{
				let obj = fabric.util.groupSVGElements( objects, options );
				
				// Add object
				context.canvas.add( obj )
								.centerObject( obj );
					
				// Set the coordinates
				obj.setCoords( );
				
				// Calculate and draw
				context.canvas.calcOffset( );
				context.canvas.renderAll( );
			} ); 
		}

		// Render template
		render( $element, template, data )
		{
			let renderTPL = this.utils.template.render( template, data );

			return $element.html( renderTPL );
		}

		//
		zoom( down )
		{
			let factor = down ? 0.9 : 1.1;

			this.canvas.setZoom( this.canvas.getZoom( ) * factor );
			this.canvas.setWidth( this.canvas.width * factor );
			this.canvas.setHeight( this.canvas.height * factor );

			return Math.round( this.canvas.getZoom( ) * factor * 100 );
		}
		
		// Get selected object
		getSelected( ) 
		{
			return this.activeObject;
		}

		// Get active style from object
		getActiveStyle( styleName, object )
		{
			object = object || this.activeObject;
			if( !object ) { return ''; }

			return ( object.getSelectionStyles && object.isEditing )
					? ( object.getSelectionStyles( )[ styleName ] || '')
					: ( object[ styleName ] || '' );
		}

		// Set style to Active object
		setActiveStyle( styleName, value, object )
		{
			object = object || this.activeObject;
			if( !object ) { return; }

			if( object.setSelectionStyles && object.isEditing ) 
			{
				var style = { };
				
				style[ styleName ] = value;
				object.setSelectionStyles( style );
				object.setCoords( );
			} 
			else 
			{
				object.set( styleName, value );
			}

			object.setCoords( );
			this.canvas.renderAll( );
		}

		// Get properties from active object
		getActiveProp( name ) 
		{
			var object = this.activeObject;
			if( !object ) { return '' };

			return object[ name ] || '';
		}

		// Set properties to active object
		setActiveProp( name, value ) 
		{
			var object = this.activeObject;
			if( !object ) { return; }
			
			object.set( name, value )
					.setCoords( );
			
			this.canvas.renderAll( );
		}
	};	
} )( window );